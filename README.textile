h1. Suggester Plugin for Elasticsearch

This little plugin uses the FSTSuggeser from lucene to create suggestions from a certain field for a specified term instead of returning index data.

THIS IS NOT PRODUCTION READY! DO NOT USE IT.

This is my first attempt with elasticsearch. I am not too deep into elasticsearch internals, nor I have deep knowledge about lucene. So please forgive this code.
Feel free to comment, improve and help - I am thankful for any insights, no matter whether you want to help with elasticsearch, lucene or my other flaws I will have done for sure.

Oh and in case you have not read it above:

THIS IS NOT PRODUCTION READY! DO NOT USE IT.

In case you want to contact me, drop me a mail at alexander@reelsen.net


h2. Installation

 * Clone this repo with git clone git://github.com/spinscale/elasticsearch-suggest-plugin.git
 * Run: <code>gradle clean assemble zip</code> - this does not run any unit tests, as they take some time. If you want to run them, better run <code>gradle clean build zip</code>
 * Install the plugin: <code>/path/to/elasticsearch/bin/plugin -install elasticsearch-suggest -url file:///$PWD/build/distributions/elasticsearch-suggest-0.0.1.zip</code>


h2. Usage

Fire up curl like this, in case you have a products index and the right fields - if not, read below how to setup a clean elasticsearch in order to support suggestions.

<pre><code>
# curl -X POST 'localhost:9200/products1/product/_suggest?pretty=1' -d '{ "field": "ProductName.suggest", "term": "tischwäsche", "size": "10"  }'
{
  "suggest" : [ "tischwäsche", "tischwäsche 100", 
    "tischwäsche aberdeen", "tischwäsche acryl", "tischwäsche ambiente", 
    "tischwäsche aquarius", "tischwäsche atlanta", "tischwäsche atlas", 
    "tischwäsche augsburg", "tischwäsche aus", "tischwäsche austria" ]
}
</code></pre>

As you can see, this queries the products index for the field ProductName.suggest with the specified term and size

You might want to check out the included unit test as well. I use a shingle filter in my examples, take a look at the files in src/test/resources directory.

Furthermore the suggest data is not updated, whenever you index a new product but every few minutes. The default is to update the index every 10 minutes, but you can change that in your elasticsearch.yml configuration:

<pre><code>
suggest:
  refresh_interval: 600
</code></pre>

In this case the suggest indexes are refreshed every 10 minutes. This is also the default.

If you want to refresh your FST suggesters manually instead of waiting for 10 minutes just issue a POST request to the "/_suggestRefresh" URL.

<pre><code>
# curl -X POST 'localhost:9200/_suggestRefresh' 
</code></pre>

h2. Usage from Java

Inject the NodeClientWithSuggest via Guice and use it

<pre><code>

private NodeClientWithSuggest client;

@Inject public ConstructorOfYourClass(NodeClientWithSuggest client) {
    this.client = client;
}

public List<String> getMySuggestions(String term, String field, String index, Integer size, Float similarity) {
    Map<String, Object> querySource = Maps.newHashMap();
    querySource.put("term", term);
    querySource.put("field", field);
    querySource.put("size", size);
    querySource.put("similarity", similarity); // between 0.0 and 1.0

    SuggestRequest request = new SuggestRequest(index).query(querySource);
    SuggestResponse response = client.suggest(request).actionGet()

    return response.sugggestions();
}
</code></pre>

Refresh works like this - there is no information in the response:

<pre><code>
    NodesSuggestRefreshRequest refreshRequest = new NodesSuggestRefreshRequest();
    NodesSuggestRefreshResponse response = client.suggestRefresh(request).actionGet()
</code></pre>

h2. Thanks

* Shay for giving feedback

h2. TODO

* Check Shays response and incorporate comments
** Build the service as shard level service like the ShardGetService
** https://groups.google.com/group/elasticsearch/browse_thread/thread/7c8693c6640cbc49/d448e8880552e999?lnk=gst&q=reelsen#d448e8880552e999
* Testing: Get TransportSuggestAction from Injector and test the code that way
** https://groups.google.com/group/elasticsearch/browse_thread/thread/212277b2d8b158ca/db0ebda562bf7daf?lnk=gst&q=reelsen#db0ebda562bf7daf
* Create a useful SuggestRequestBuilder instead of this useless thing... Also create a SuggestRefreshRequestBuilder for completeness
* What about supporting certain types only, this is completely ignored for now
* Conduct performance tests, especially during updates
* Make it generelly less hacky
* How to extend node.client() to return a node client with suggest support? Is this possible without hard patching? Currently not as Shay said on the ML.

h2. Changelog

* 2011-12-20: Added transport action (and REST action) to trigger reloading of all FST suggesters
* 2011-12-11: Fixed the biggest issues: Searchers are released now and do not leak
* 2011-12-11: Indexing is now done periodically
* 2011-12-11: Found a way to get the injector from the node, so I can build my tests without using HTTP requests

h2. HOWTO - the long version

This HOWTO will help you to setup a clean elasticsearch installation with the correct index settings and mappings, so you can use the plugin as easy as possible.
We will setup elasticsearch, index some products and query those for suggestions.

* Get elasticsearch, install it
* Get this plugin, install it
* Add a suggest and a lowercase analyzer to your elasticsearch/config/elasticsearch.yml config file
<pre><code>index:
  analysis:
    analyzer:
      lowercase_analyzer:
        type: custom
        tokenizer: standard
        filter: [standard, lowercase] 
      suggest_analyzer:
        type: custom
        tokenizer: standard
        filter: [standard, lowercase, shingle]
</code></pre>
* Start elasticsearch
* Now a mapping has to be created. You can either create it via configuration in a file or during index creation. We will create an index with a mapping now
<pre><code>curl -X PUT localhost:9200/products -d '{
    "mappings" : {
        "product" : {
            "properties" : {
	        "ProductId":	{ "type": "string", "index": "not_analyzed" },
	        "ProductName" : {
	            "type" : "multi_field",
	            "fields" : {
	                "ProductName":  { "type": "string", "index": "not_analyzed" },
	                "lowercase":    { "type": "string", "analyzer": "lowercase_analyzer" },
	                "suggest" :     { "type": "string", "analyzer": "suggest_analyzer" }
	            }
	        }
            }
        }
    }
}'</code></pre>
* Now lets add some products
<pre><code>for i in 1 2 3 4 5 6 7 8 9 10 100 101 1000; do
    json=$(printf '{"ProductId": "%s", "ProductName": "%s" }', $i, "My Product $i")
    curl -X PUT localhost:9200/products/product/$i -d "$json"
done</code></pre>

h3. Queries

 Time to query and understand the different analyzers, returns 10 matches
* Queries the not analyzed field, returns 10 matches (default), always the full product name:
<pre><code>curl -X POST localhost:9200/products/product/_suggest -d '{ "field": "ProductName", "term": "My" }'</code></pre>
* Queries the not analyzed field, returns nothing (because lowercase):
<pre><code>curl -X POST localhost:9200/products/product/_suggest -d '{ "field": "ProductName", "term": "my" }'</code></pre>
* Queries the lowercase field, returns only the occuring word (which is pretty bad for suggests):
<pre><code>curl -X POST localhost:9200/products/product/_suggest -d '{ "field": "ProductName.lowercase", "term": "m" }'</code></pre>
* Queries the suggest field, returns two words (this is the default length of the shingle filter), in this case "my" and "my product"
<pre><code>curl -X POST localhost:9200/products/product/_suggest -d '{ "field": "ProductName.suggest", "term": "my" }'</code></pre>
* Queries the suggest field, returns ten product names as we started with the second word + another one due to the shingle
<pre><code>curl -X POST localhost:9200/products/product/_suggest -d '{ "field": "ProductName.suggest", "term": "product" }'</code></pre>
* Queries the suggest field, returns all products with "product 1" in the shingle
<pre><code>curl -X POST localhost:9200/products/product/_suggest -d '{ "field": "ProductName.suggest", "term": "product 1" }'</code></pre>
* The same query as above, but limits the result set to two 
<pre><code>curl -X POST localhost:9200/products/product/_suggest -d '{ "field": "ProductName.suggest", "term": "product 1", "size": 2 }'</code></pre>
* And last but not least, typo finding, the query without similarity parameter set returns nothing:
<pre><code>curl -X POST localhost:9200/products/product/_suggest -d '{ "field": "ProductName.suggest", "term": "proudct", similarity: 0.7 }'</code></pre>

The similarity is a float between 0.0 and 1.0 - if it is not specified 1.0 is used, which means it must equal. I've found 0.7 ok for cases, when two letters were exchanged, but mileage may very as I tested merely on german product names.

With the tests I did, a shingle filter held the best results. Please check http://www.elasticsearch.org/guide/reference/index-modules/analysis/shingle-tokenfilter.html for more information about setup, like the default tokenization of two terms.

Now test with your data, come up and improve this configuration. I am happy to hear about your specific configuration for successful suggestion queries.
